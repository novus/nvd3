// Generated by CoffeeScript 1.7.1
(function() {
  var checkDispatch, checkForDuck, checkInstanceProp, checkOptionsFunc, checkProperties, should,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  should = chai.should();


  /*
  
  config:
      instance:       Instance to test
      properties:     Properties to test against instance
      parent:         Parent of instance, from which prototypes are inherited
      overrides:      Properties expected to be overridden by instance
   */

  checkProperties = function(config) {
    var parent;
    config.overrides = config.overrides || [];
    parent = config.parent;
    return config.properties.forEach(function(prop) {
      return describe("" + prop, function() {
        var instance;
        instance = null;
        beforeEach(function() {
          return instance = config.instance;
        });
        it('exists', function() {
          return should.exist(instance[prop]);
        });
        if (__indexOf.call(config.overrides, prop) >= 0) {
          return it("DOES NOT call " + parent.name + ".prototype." + prop, function() {
            var spy;
            spy = sinon.spy(parent.prototype, prop);
            instance[prop]();
            spy.called.should.be["false"];
            return parent.prototype[prop].restore();
          });
        } else {
          return it("calls " + parent.name + ".prototype." + prop, function() {
            var spy;
            spy = sinon.spy(parent.prototype, prop);
            instance[prop]();
            spy.calledOnce.should.be["true"];
            return parent.prototype[prop].restore();
          });
        }
      });
    });
  };

  checkInstanceProp = function(instance, source, props) {
    return props.forEach(function(prop) {
      return it("" + prop, function() {
        return should.exist(instance[prop]);
      });
    });
  };

  checkDispatch = function(model, events) {
    if (events == null) {
      events = [];
    }
    return describe('dispatch', function() {
      it('exists', function() {
        var instance;
        instance = model();
        return should.exist(instance.dispatch);
      });
      if (events.length !== 0) {
        return describe('Events', function() {
          var instance;
          instance = null;
          beforeEach(function() {
            return instance = model();
          });
          return events.forEach(function(event) {
            return it("" + event, function() {
              return should.exist(instance.dispatch[event]);
            });
          });
        });
      }
    });
  };

  checkOptionsFunc = function(model) {
    return describe('options', function() {
      it('exists', function() {
        var instance;
        instance = model();
        return should.exist(instance.options);
      });
      return it('calls nv.utils.optionFunc', function() {
        var instance, spy;
        spy = sinon.spy(nv.utils, 'optionsFunc');
        instance = model();
        instance.options();
        spy.calledOnce.should.be["true"];
        return nv.utils.optionsFunc.restore();
      });
    });
  };

  checkForDuck = function(instance, model) {
    return it('exposes correct submodel API', function() {
      var instanceAPI, key, modelAPI;
      modelAPI = [
        (function() {
          var _results;
          _results = [];
          for (key in model) {
            _results.push(key);
          }
          return _results;
        })()
      ];
      instanceAPI = [
        (function() {
          var _results;
          _results = [];
          for (key in instance) {
            _results.push(key);
          }
          return _results;
        })()
      ];
      return instanceAPI.should.deep.equal(modelAPI);
    });
  };

}).call(this);
